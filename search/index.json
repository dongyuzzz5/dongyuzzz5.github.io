[{"content":"一. 经典RSA 1. 须知条件 (1) p = 447685307\n(2) q = 2037\n(3) e = 17\n(4) ciphertext = 704796792\n注 ： 有 p,q,e 即可求出私钥 d\n2. 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def rsa_decrypt(ciphertext, d, n): \u0026#34;\u0026#34;\u0026#34;RSA解密函数\u0026#34;\u0026#34;\u0026#34; plaintext = pow(ciphertext, d, n) return plaintext def calculate_private_key(e, p, q): \u0026#34;\u0026#34;\u0026#34;计算私钥d（需p、q为素数且e与φ(n)互质）\u0026#34;\u0026#34;\u0026#34; phi = (p - 1) * (q - 1) d = pow(e, -1, phi) # Python 3.8+ 的模逆计算 return d # 示例用法 if __name__ == \u0026#34;__main__\u0026#34;: # 已知参数（替换为你的实际参数） p = 447685307 q = 2037 e = 17 ciphertext = 704796792 # 替换为你的密文 # 计算私钥d和解密 n = p * q d = calculate_private_key(e, p, q) plaintext = rsa_decrypt(ciphertext, d, n) print(f\u0026#34;私钥d: {d}\u0026#34;) print(f\u0026#34;解密结果: {plaintext}\u0026#34;) 二. N分解 1. 须知条件 (1) N = 460657813884289609896372056585544172485318117026246263899744329237492 701820627219556007788200590119136173895989001382151536006853823326382892363143 604314518686388786002989248800814861248595075326277099645338694977097459168 530898776007293695728101976069423971696524237755227187061418202849911479124793 990722597\n(2) e = 35461110244130757205657218182792589919834535022875373093108939327546391 65444566268942454150961078344657784095323731871253185546147225993017915289162 1283936812106603554100880826153450058602365276771227162578520428096468800468 032830012484968047710530251937737009257810782711682139182621097232037761496754 7827619\n(3) enc = 382309913162293996518235675906923010600446204121917377646323846805462 5622845151823884296522139471184833783245944384444688946836215418821484073674 4657885858943810177675871991111466653158257191139605699916347308294995664530280 81685048274053060225455912375912110633835922024263777591902693356332606944942 4391192\n注：N分解p,q可以使用在线网站：http://www.factordb.com/index.php或者用其他N分解工具，工具下载在其他文章有提及\n2. 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def rsa_decrypt(N, e, enc): p = 127685932938731221992817899539092641593668680700108840338907777364248158387793117420926162525549739317540333658811102811316274156507102712368770516894542906645781063123612802169333621393006523907942055597359469312381323007967788830402803370144148475302470248532284938017009759945821701787408489909925749848443 # 示例p（需替换为实际分解的素数） q = 147199016045711432751638821206308445008264556310138298317988445918295214070009189642863602736928620075708961292355772144107904072422081464952790328676245442353824750499664935214066308400409281606421061272247951127310089903404542920084748985854316064209036479288096221482644500085802435454794064096852047366391 # 示例q（需替换为实际分解的素数） #去该网站http://www.factordb.com/index.php，分解出p,q的值 # 验证p和q的正确性 if N != p * q: raise ValueError(\u0026#34;提供的p和q不能正确分解N，请检查参数\u0026#34;) # 步骤2：计算φ(n)和私钥d phi = (p - 1) * (q - 1) d = pow(e, -1, phi) # 计算模逆（Python 3.8+） # 步骤3：解密 plaintext = pow(enc, d, N) return plaintext, d # 用户提供的参数 N = 18795243691459931102679430418438577487182868999316355192329142792373332586982081116157618183340526639820832594356060100434223256500692328397325525717520080923556460823312550686675855168462443732972471029248411895298194999914208659844399140111591879226279321744653193556611846787451047972910648795242491084639500678558330667893360111323258122486680221135246164012614985963764584815966847653119900209852482555918436454431153882157632072409074334094233788430465032930223125694295658614266389920401471772802803071627375280742728932143483927710162457745102593163282789292008750587642545379046283071314559771249725541879213 e = 3 enc = 10533300439600777643268954021939765793377776034841545127500272060105769355397400380934565940944293911825384343828681859639313880125620499839918040578655561456321389174383085564588456624238888480505180939435564595727140532113029361282409382333574306251485795629774577583957179093609859781367901165327940565735323086825447814974110726030148323680609961403138324646232852291416574755593047121480956947869087939071823527722768175903469966103381291413103667682997447846635505884329254225027757330301667560501132286709888787328511645949099996122044170859558132933579900575094757359623257652088436229324185557055090878651740 # 执行解密（需替换p和q为实际分解的素数） try: plaintext, d = rsa_decrypt(N, e, enc) print(f\u0026#34;私钥d: {d}\u0026#34;) print(f\u0026#34;解密结果（整数）: {plaintext}\u0026#34;) # 尝试将解密结果转为字节（如明文为文本） try: bytes_data = plaintext.to_bytes((plaintext.bit_length() + 7) // 8, \u0026#39;big\u0026#39;) print(f\u0026#34;解密结果（字节）: {bytes_data}\u0026#34;) print(f\u0026#34;解密结果（文本）: {bytes_data.decode(\u0026#39;utf-8\u0026#39;, errors=\u0026#39;replace\u0026#39;)}\u0026#34;) except Exception as bytes_err: print(f\u0026#34;字节转换失败（可能非文本数据）: {bytes_err}\u0026#34;) except ValueError as ve: print(f\u0026#34;解密失败: {ve}\u0026#34;) 三. N分解 (3素数) 1. 须知条件 (1) N = 8704668509359951027236836269329316517523007652115740169403759488541463 5794821632480586251815781024287795764033593280379997729390218197582352987053 874621806014444738639656569\n(2) e = 65537\n(3) c = 6947010231214284699977382852172822370017979780965673914395473677860095 0621925370448135516822745357112649064444820947535168875664731569964254759847 995928643376044660954509351\n注：N分解p,q可以使用在线网站：http://www.factordb.com/index.php或者用其他N分解工具，工具下载在其他文章有提及\n我这里用的使用工具进行分解，该工具用的yafu模型\n2. 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from sympy import mod_inverse # 已知参数 n = 87046685093599510272368362693293165175230076521157401694037594885414635794821632480586251815781024287795764033593280379997729390218197582352987053874621806014444738639656569 e = 65537 c = 69470102312142846999773828521728223700179797809656739143954736778600950621925370448135516822745357112649064444820947535168875664731569964254759847995928643376044660954509351 # 你提供的3个素因数 p155 = 12930980338298869956318850401499638302396092952002912233913975670345415021349682270245154914395528882823328061887414888049327079447117873073824971520001221 p10_1 = 2421024653 p10_2 = 2780491513 # 验证因数是否正确 calc_n = p155 * p10_1 * p10_2 assert calc_n == n, \u0026#34;因数分解错误！计算出的n与原n不相等\u0026#34; print(\u0026#34;因数验证通过！\u0026#34;) # 计算欧拉函数φ(n) phi_n = (p155 - 1) * (p10_1 - 1) * (p10_2 - 1) # 计算私钥d (e的模逆元) d = mod_inverse(e, phi_n) assert (e * d) % phi_n == 1, \u0026#34;逆元计算错误\u0026#34; # 快速幂模解密 def pow_mod(base, exp, mod): result = 1 base = base % mod while exp \u0026gt; 0: if exp % 2 == 1: result = (result * base) % mod exp = exp \u0026gt;\u0026gt; 1 base = (base * base) % mod return result m = pow_mod(c, d, n) # 整数转字节串得到flag def int_to_flag(num): return num.to_bytes((num.bit_length() + 7) // 8, byteorder=\u0026#39;big\u0026#39;).decode(\u0026#39;utf-8\u0026#39;, errors=\u0026#39;replace\u0026#39;) flag = int_to_flag(m) print(\u0026#34;解密得到的flag:\u0026#34;, flag) 四. N分解 (需base解密) 下面算是一道例题的writeup\n打开文档，这是一道N分解的RSA解密题目，但不一样的是明文是一段乱码的二进制数\n不过还是和之前的N分解题目一样，先分出p,q,求d,我这里用但是一个b站大佬给的软件，在我另一篇文章有下载地址，因为在线网站那个因为数比较大解不出来，该软件用的也是yafu，有yafu直接解即可\n不过分解前我们注意到公钥N也是一段base密文，需要先解码。\n这里分享一个公钥解析的网站：http://www.hiencode.com/pub_asys.html\n拿到n和e,通过N分解工具解出p.q\n将p,q交给之前N分解题目的代码，拿到秘钥d,代码如下（和上面给的n分解代码相同）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def rsa_decrypt(N, e, enc): p = 127685932938731221992817899539092641593668680700108840338907777364248158387793117420926162525549739317540333658811102811316274156507102712368770516894542906645781063123612802169333621393006523907942055597359469312381323007967788830402803370144148475302470248532284938017009759945821701787408489909925749848443 # 示例p（需替换为实际分解的素数） q = 147199016045711432751638821206308445008264556310138298317988445918295214070009189642863602736928620075708961292355772144107904072422081464952790328676245442353824750499664935214066308400409281606421061272247951127310089903404542920084748985854316064209036479288096221482644500085802435454794064096852047366391 # 示例q（需替换为实际分解的素数） #去该网站http://www.factordb.com/index.php，分解出p,q的值 # 验证p和q的正确性 if N != p * q: raise ValueError(\u0026#34;提供的p和q不能正确分解N，请检查参数\u0026#34;) # 步骤2：计算φ(n)和私钥d phi = (p - 1) * (q - 1) d = pow(e, -1, phi) # 计算模逆（Python 3.8+） # 步骤3：解密 plaintext = pow(enc, d, N) return plaintext, d # 用户提供的参数 N = 18795243691459931102679430418438577487182868999316355192329142792373332586982081116157618183340526639820832594356060100434223256500692328397325525717520080923556460823312550686675855168462443732972471029248411895298194999914208659844399140111591879226279321744653193556611846787451047972910648795242491084639500678558330667893360111323258122486680221135246164012614985963764584815966847653119900209852482555918436454431153882157632072409074334094233788430465032930223125694295658614266389920401471772802803071627375280742728932143483927710162457745102593163282789292008750587642545379046283071314559771249725541879213 e = 3 enc = 10533300439600777643268954021939765793377776034841545127500272060105769355397400380934565940944293911825384343828681859639313880125620499839918040578655561456321389174383085564588456624238888480505180939435564595727140532113029361282409382333574306251485795629774577583957179093609859781367901165327940565735323086825447814974110726030148323680609961403138324646232852291416574755593047121480956947869087939071823527722768175903469966103381291413103667682997447846635505884329254225027757330301667560501132286709888787328511645949099996122044170859558132933579900575094757359623257652088436229324185557055090878651740 # 执行解密（需替换p和q为实际分解的素数） try: plaintext, d = rsa_decrypt(N, e, enc) print(f\u0026#34;私钥d: {d}\u0026#34;) print(f\u0026#34;解密结果（整数）: {plaintext}\u0026#34;) # 尝试将解密结果转为字节（如明文为文本） try: bytes_data = plaintext.to_bytes((plaintext.bit_length() + 7) // 8, \u0026#39;big\u0026#39;) print(f\u0026#34;解密结果（字节）: {bytes_data}\u0026#34;) print(f\u0026#34;解密结果（文本）: {bytes_data.decode(\u0026#39;utf-8\u0026#39;, errors=\u0026#39;replace\u0026#39;)}\u0026#34;) except Exception as bytes_err: print(f\u0026#34;字节转换失败（可能非文本数据）: {bytes_err}\u0026#34;) except ValueError as ve: print(f\u0026#34;解密失败: {ve}\u0026#34;) 拿秘钥d即可,接着再用下面代码，提交拿到的n和d,解出乱码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from Crypto.Util.number import bytes_to_long, long_to_bytes # 文件路径 file_path = r\u0026#34;C:\\Users\\zhangdongyu\\Desktop\\flag.txt\u0026#34; # 读取文件内容并转换为长整型 with open(file_path, \u0026#39;rb\u0026#39;) as f: data = bytes_to_long(f.read()) # RSA 参数（需替换为实际的私钥 d 和模数 n） d = 10208930252595125826515962985306027963217433917970173129516489271264408822867182198650047677185497407512912530654162658393308036084188642962328251890869568168563178495945343401728753708674688792386306546583635933960655487427236252219222411561710664746306871760866758299576460420957925157969242706765925039654065567408929499402742372250693214505981483993723073958148731747215897571562844519558819284605979416507709483759932550939248218840205796760246556636744986222988883300709803852000871182590917343263495560648090871783101615692972817308724837067626018129744144880977966793936533147915322057362788409206772466614521 # 示例私钥，需替换 n = 11346583827363680108747018047145832422504171330631401763543773655510897144528143671826614907229690730186442161948951228557511595849294018482211895739441693332821032952697655776533889560177272994380174543693853207000296419623491202755675799384727331605988424763286041764395456476754732236845474668000516048635163606969540786622605908925712319750169314132422370672338321960291737446904222234594752087796211543312024769898621747081028940135428367233620666234385168034990090116655327656166599394813838289858910864835435517137148762826367538992970540530364699527824437729200448664536492398949976200432943393393291864817649 # 示例模数，需替换 # 解密：计算 data^d mod n flag = pow(data, d, n) # 将结果转换为字节并尝试解码 flag_bytes = long_to_bytes(flag) try: print(flag_bytes.decode(\u0026#39;utf-8\u0026#39;)) # 尝试UTF-8解码 except UnicodeDecodeError: print(flag_bytes.hex()) # 若解码失败，输出十六进制 运行代码，结果如下：\n五. 共模攻击 (n相同) 1. 须知条件 (1) n = 23216043434864680600225 …… (n1和n2相同，数据过长省略)\n(2) e1 = 2333\n(3) c1 = 8460278021432923221691 ……\n(4) e2 = 23333\n(5) c2 = 1292105808453028485417 ……\n2. 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import math from Crypto.Util.number import long_to_bytes # 给定的参数 n = 87137457394305832415365977697062473287095068371127393016842224707016457764778162147920307518069285275379221972993160703702040680763226044403609893839791593326375331100595143841674620402468113301049550862671950400383598859380526986762207383902194744283725415728929427110586402405875272928550544931418317 e1 = 65537 c1 = 68809605804252047123462176623882653957305904521503210110613904743970405276675149107730062989250462689011673758837829322365263699859697297630086941761352183380779408794649727370217811791960746760462196897564509331884179426366511928920514994234355088152049707652024459637320370701905485165976989676898418 e2 = 49153 c2 = 49069443034302365452190082793258381429135899871290785408695489509439269622842317888919283099188796315071396363353906929516016997814707585459660251510282572324750222292047544825160745699231770384339109229037592728602625117285338589263267371528590840976932864110426718016364564061233538857810282472719681 # 扩展欧几里得算法求s1和s2 def extended_gcd(a, b): if b == 0: return (a, 1, 0) else: g, x, y = extended_gcd(b, a % b) return (g, y, x - (a // b) * y) # 检查e1和e2是否互质 gcd, s1, s2 = extended_gcd(e1, e2) if gcd != 1: print(\u0026#34;e1和e2不互质，无法使用共模攻击\u0026#34;) else: # 确保s1和s2为正数 if s1 \u0026lt; 0: s1 = -s1 c1 = pow(c1, -1, n) if s2 \u0026lt; 0: s2 = -s2 c2 = pow(c2, -1, n) # 计算明文 m = (pow(c1, s1, n) * pow(c2, s2, n)) % n print(\u0026#34;恢复的明文:\u0026#34;, long_to_bytes(m)) 六. 共模攻击 (需base64解密) 1. 须知条件 (1) c1 = \u0026ldquo;IBEMFK1mtyQjG8q6mfUQ ……\u0026rdquo;\n(2) c2 = \u0026ldquo;P3F9MjjaMhu/5nD+c9ix ……\u0026rdquo;\n(3) pubkey1 = \u0026quot; …… 7Z5ayQng0ekOKOwICCR0=\u0026quot;\n(4) pubkey2 = \u0026quot; …… 7Z5ayQng0ekOKOwICWyU=\u0026quot;\n2. 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 from Crypto.PublicKey import RSA from Crypto.Util.number import bytes_to_long, long_to_bytes import base64 import math # 解码Base64编码的密文和公钥 c1 = base64.b64decode(\u0026#34;IBEMFK1mtyQjG8q6mfUQIXcX688BknvbMZJmA7mxPGryBW9CVtM57h2/vnTl87ULsuWAlD1LtMwaKs5PfWFKCDovFTzzVGlxob5Q7s2axKazMKrvwzTkObSd0Z6usVX5fGfv5cOtQkKL7/IZTkXd4H2Fxt1sY6oylwrr7RJ7V43wjrccFc6taUi7XcgthTRtfLIJ5194Qn87R+yl6JLr6DDT+8Bcd7k7kmdLJUuAv5/24pcJWBFHegn5z03SE7JjE6laYXNYDvs2UJCkepKQZ1070vcWuvjmTUk6JIPFPzhjwQcjrEIofdEPPpa6N1/FmMPxJwa5+SVuO0FU2O5/Uw==\u0026#34;) c2 = base64.b64decode(\u0026#34;P3F9MjjaMhu/5nD+c9ixDP5VmGO23pdS92gIJ399Fsk34ZTyWc9PMYzz8RNUKN1WBrgib8p6ZyWfhLyaRXAWqf8aDX8t6HnInq4JPmCLbnHcUiCCtGfxixIfObiweDQqg6VRli3cj5CclczbBvk+OWNyLCi+3FckFPPO7ckoGgIy4lR29j+TczHL+US+uP03X9ByCsUkgIiGsPjkf4/I3iUfQOCtYwafmCWkDgmWX8oBaIyl0q6T7Xnz4MsEorDIuuaYrUQ7BX6Jo8DrGTmz1LWwJglXqGHkZqNM7Q4pOZlL+boc3h+wg/qgFQG8AabpYUIf1+WHA0fFAJ6rGB1b0w==\u0026#34;) pubkey1 = RSA.import_key(base64.b64decode(\u0026#34;MIIBITANBgkqhkiG9w0BAQEFAAOCAQ4AMIIBCQKCAQEApQJ+T9Agwu92N4bDk8zY6SLPO0sdCpDR/tt0WSal4Privkby/DpLplSJtOP77NDAKI8yB8IJK7qwwPrZcPVK2vECx23i7cgHwnkEY5xJ3tYOwJXTQt5J+2VkIsy1u78Ah608E7+5oxuZr0lkZlew3zgTCuTXsgpYWr9qx0GG51Dhsh+m83NGZB8Jt2xT5EcHphw8HBYscMnRY//MEvzc2Ho81G54zda8DcQHLoHGBHjlnS202JfW+rvKrF5Zssny2FUmkB89KGw+fj9Bs7ZWHwlg/3qBxLeuBNAAyYqImIWa70UvDnpWTFWZah5ZYl+sexIBeMl7Z5ayQng0ekOKOwICCR0=\u0026#34;)) pubkey2 = RSA.import_key(base64.b64decode(\u0026#34;MIIBITANBgkqhkiG9w0BAQEFAAOCAQ4AMIIBCQKCAQEApQJ+T9Agwu92N4bDk8zY6SLPO0sdCpDR/tt0WSal4Privkby/DpLplSJtOP77NDAKI8yB8IJK7qwwPrZcPVK2vECx23i7cgHwnkEY5xJ3tYOwJXTQt5J+2VkIsy1u78Ah608E7+5oxuZr0lkZlew3zgTCuTXsgpYWr9qx0GG51Dhsh+m83NGZB8Jt2xT5EcHphw8HBYscMnRY//MEvzc2Ho81G54zda8DcQHLoHGBHjlnS202JfW+rvKrF5Zssny2FUmkB89KGw+fj9Bs7ZWHwlg/3qBxLeuBNAAyYqImIWa70UvDnpWTFWZah5ZYl+sexIBeMl7Z5ayQng0ekOKOwICWyU=\u0026#34;)) # 提取模数n和公钥指数e1,e2 n = pubkey1.n e1 = pubkey1.e e2 = pubkey2.e # 转换为整数 c1_int = bytes_to_long(c1) c2_int = bytes_to_long(c2) # 检查e1和e2是否互质 if math.gcd(e1, e2) != 1: print(\u0026#34;错误：e1和e2不互质，无法使用共模攻击\u0026#34;) exit() # 使用扩展欧几里得算法找到a和b def extended_gcd(a, b): if b == 0: return (a, 1, 0) else: g, x, y = extended_gcd(b, a % b) return (g, y, x - (a // b) * y) _, a, b = extended_gcd(e1, e2) # 处理负数指数的情况 if a \u0026lt; 0: c1_inv = pow(c1_int, -1, n) part1 = pow(c1_inv, -a, n) else: part1 = pow(c1_int, a, n) if b \u0026lt; 0: c2_inv = pow(c2_int, -1, n) part2 = pow(c2_inv, -b, n) else: part2 = pow(c2_int, b, n) # 计算明文 m = (part1 * part2) % n # 尝试解码为字符串 try: flag = long_to_bytes(m).decode(\u0026#39;utf-8\u0026#39;) print(\u0026#34;找到的flag:\u0026#34;, flag) except: print(\u0026#34;解密结果不是有效的UTF-8字符串，原始数据:\u0026#34;) print(long_to_bytes(m)) 七. 小指数小明文攻击 1. 须知条件 (1) flag = 2516675165353094136483 ……\n(2) n = 134109481482703713214838 ……\n2. 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import gmpy2 from Crypto.Util.number import long_to_bytes # 给定的参数 flag = 25166751653530941364839663846806543387720865339263370907985655775152187319464715737116599171477207047430065345882626259880756839094179627032623895330242655333 n = 134109481482703713214838023035418052567000870587160796935708584694132507394211363652420160931185332280406437290210512090663977634730864032370977407179731940068634536079284528020739988665713200815021342700369922518406968356455736393738946128013973643235228327971170711979683931964854563904980669850660628561419 # 尝试常见的小指数 e for e in [3, 5, 7, 11, 17]: # 尝试直接开e次方 m, is_exact = gmpy2.iroot(flag, e) if is_exact: print(f\u0026#34;Found with e = {e}\u0026#34;) print(\u0026#34;Decrypted message:\u0026#34;, long_to_bytes(int(m)).decode()) break else: print(\u0026#34;Failed to decrypt with small exponents (3,5,7,11,17)\u0026#34;) 八. 小指数广播攻击 1. 须知条件 (1) n_list = [18795243691459931102679430418 ……]\n(2) c_list = [10533300439600777643268954021 ……]\n2. 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from Crypto.Util.number import long_to_bytes from gmpy2 import iroot import math # 给定的 n_list 和 c_list n_list = [ 18795243691459931102679430418438577487182868999316355192329142792373332586982081116157618183340526639820832594356060100434223256500692328397325525717520080923556460823312550686675855168462443732972471029248411895298194999914208659844399140111591879226279321744653193556611846787451047972910648795242491084639500678558330667893360111323258122486680221135246164012614985963764584815966847653119900209852482555918436454431153882157632072409074334094233788430465032930223125694295658614266389920401471772802803071627375280742728932143483927710162457745102593163282789292008750587642545379046283071314559771249725541879213 ] c_list = [ 10533300439600777643268954021939765793377776034841545127500272060105769355397400380934565940944293911825384343828681859639313880125620499839918040578655561456321389174383085564588456624238888480505180939435564595727140532113029361282409382333574306251485795629774577583957179093609859781367901165327940565735323086825447814974110726030148323680609961403138324646232852291416574755593047121480956947869087939071823527722768175903469966103381291413103667682997447846635505884329254225027757330301667560501132286709888787328511645949099996122044170859558132933579900575094757359623257652088436229324185557055090878651740 ] # 使用中国剩余定理（CRT）计算 M^9 def crt(c_list, n_list): from functools import reduce N = reduce(lambda x, y: x * y, n_list) result = 0 for c, n in zip(c_list, n_list): m = N // n inv = pow(m, -1, n) result += c * m * inv return result % N M_pow_e = crt(c_list, n_list) M, is_exact = iroot(M_pow_e, 9) # 开 9 次方 if is_exact: FLAG = long_to_bytes(M) print(\u0026#34;Recovered FLAG:\u0026#34;, FLAG) else: print(\u0026#34;Failed to recover FLAG.\u0026#34;) 九. dp泄露 1. 须知条件 (1) n = 217149279711325384917031302594 ……\n(2) e = 65537\n(3) dp = 48344586502310179285080111602 ……\n(4) c = 213590655453799062229719070608 ……\n2. 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from Crypto.Util.number import long_to_bytes import math # 给定的参数 n = 21714927971132538491703130259464530697531676957562279854185093062286446006949577470356376430722340840410045188053476746405423972999071500892678348404727292918777522592571382795089414141612105491963278153613433774191589901354021108951995915239156098398609144856216087591439229493099930929444895443957857926599579268753206672995106638289793863096101044604457161926915091696133185941282127141273834152463953046885880120901606492184045847532185466461405122417238155980875520408953218205963026775705412816899363607460220268041670956267886557020917753971790854501805619219266997607333279957958677664043788274663140851660209 e = 65537 dp = 48344586502310179285080111602544573402048490661764431487481568930210938450560542073640284273901903385143358565729038252028677066888866437778939252384770812023710791092754732043738050242502712608343186596491204416576688393109760763889715503673586184965145321450353317440566459887413043414291581435102791237087 c = 21359065545379906222971907060859956386576779836849889208144245623027154405028823839307149743585606990635516865189069659069953732557418628701299923001708060068219897973709026667401900736339619099536374975702343933166484127166369742871966387767206272851233119252735690320057134817769213759145090229232817414656283739462136558309220091886803564294533404204167070049953213476073460066829879290436509088737626228437842464054314925703164279712555753731448105251651772689822576317662141210402418808549242701047258786612684343515841635256973488415460381088575571129720835345474349322952180876574006561951497317863235333605079 def dp_leak_attack(n, e, dp, c): \u0026#34;\u0026#34;\u0026#34;dp泄露攻击\u0026#34;\u0026#34;\u0026#34; for x in range(1, e): # 遍历可能的k值 if (dp * e - 1) % x != 0: continue p = (dp * e - 1) // x + 1 if n % p == 0: # 找到正确的p q = n // p # 计算私钥d phi = (p - 1) * (q - 1) d = pow(e, -1, phi) # 解密 m = pow(c, d, n) return long_to_bytes(m) return None # 执行攻击 plaintext = dp_leak_attack(n, e, dp, c) if plaintext: print(\u0026#34;解密成功！明文为:\u0026#34;, plaintext.decode()) else: print(\u0026#34;攻击失败，请检查参数是否正确\u0026#34;) 十. wiener攻击 1. 须知条件 (1) n = 595454297618574562986396702132 ……\n(2) e = 116940929274974825793755255134 ……\n(3) c = 538623725970833500967174293275 ……\n2. 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 import math from Crypto.Util.number import long_to_bytes def continued_fraction(e, n): \u0026#34;\u0026#34;\u0026#34;计算e/n的连分数展开\u0026#34;\u0026#34;\u0026#34; cf = [] while n: q = e // n cf.append(q) e, n = n, e % n return cf def gradual_fractions(cf): \u0026#34;\u0026#34;\u0026#34;计算连分数的渐进分数\u0026#34;\u0026#34;\u0026#34; numerators = [0, 1] denominators = [1, 0] for i, q in enumerate(cf): numerators.append(q * numerators[i+1] + numerators[i]) denominators.append(q * denominators[i+1] + denominators[i]) yield numerators[-1], denominators[-1] def wiener_attack(e, n): \u0026#34;\u0026#34;\u0026#34;执行Wiener攻击\u0026#34;\u0026#34;\u0026#34; cf = continued_fraction(e, n) for k, d in gradual_fractions(cf): if k == 0 or d == 0: continue # 检查是否满足ed ≡ 1 mod k if (e * d - 1) % k != 0: continue phi = (e * d - 1) // k # 解方程x^2 - (n - phi + 1)x + n = 0 b = n - phi + 1 discriminant = b * b - 4 * n if discriminant \u0026lt; 0: continue sqrt_discriminant = math.isqrt(discriminant) if sqrt_discriminant * sqrt_discriminant != discriminant: continue p = (b + sqrt_discriminant) // 2 q = (b - sqrt_discriminant) // 2 if p * q == n: return d return None # 给定的参数 n = 59545429761857456298639670213259353530646597646534636478287624157537322306534433864180080192119328810928793196153286273780109172230466917704246945944722172328827772549653399894336418850300429770230277450755380875776289829236386814465350967186773966937745864242151983520860593770312207312172648883955300937661 e = 11694092927497482579375525513481609476066512693731366903208759088367239561922960886684015891594539604072100559819668607336489541345733108136320568539177873947751879678298925128552549681196990923177465765513973681830646855767534801909094782942993042116192331840433720377276593810443820044253033505840288274341 c = 53862372597083350096717429327513824903199927810655835176869750272280547159035933471145316851340773425450467654226014224599957906359070369632313820534209775092381609388817688859695441582342699562270830137508198495764378736473302320755484289480257128736985379126734150757481268451968781320650051339685601352375 # 执行Wiener攻击 d = wiener_attack(e, n) if d: print(f\u0026#34;成功找到私钥d: {d}\u0026#34;) # 解密消息 m = pow(c, d, n) print(\u0026#34;解密后的消息:\u0026#34;, long_to_bytes(m).decode()) else: print(\u0026#34;Wiener攻击失败，可能需要尝试其他攻击方法\u0026#34;) 十一. 扩展欧几里得 (代码还需优化) 1. 须知条件 (1) n = 1001733993063167141\n(2) d = 212353\n(3) c = 20190324\n2. 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import math def extended_gcd(a, b): \u0026#34;\u0026#34;\u0026#34;扩展欧几里得算法，求解 ax + by = gcd(a, b) 的解 (x, y)\u0026#34;\u0026#34;\u0026#34; if b == 0: return a, 1, 0 else: g, x, y = extended_gcd(b, a % b) return g, y, x - (a // b) * y def modinv(a, m): \u0026#34;\u0026#34;\u0026#34;求 a 在模 m 下的逆元（即 ax ≡ 1 mod m 的解 x）\u0026#34;\u0026#34;\u0026#34; g, x, y = extended_gcd(a, m) if g != 1: return None # 逆元不存在 else: return x % m def factorize(n): \u0026#34;\u0026#34;\u0026#34;试除法分解 n 为 p 和 q（仅适用于小质因数）\u0026#34;\u0026#34;\u0026#34; for i in range(2, int(math.isqrt(n)) + 1): if n % i == 0: return i, n // i return None # 分解失败 # 题目参数 n = 1001733993063167141 d = 212353 C = 20190324 # 1. 分解 n 为 p 和 q p, q = factorize(n) if p is None: print(\u0026#34;无法分解 n，可能需要更高效的因数分解算法（如 Pollard\u0026#39;s Rho）\u0026#34;) exit() print(f\u0026#34;分解结果: p = {p}, q = {q}\u0026#34;) # 2. 计算 φ(n) = (p-1)(q-1) phi = (p - 1) * (q - 1) # 3. 求 e（d 的模逆元） e = modinv(d, phi) if e is None: print(\u0026#34;d 和 φ(n) 不互质，无法求逆元\u0026#34;) exit() print(f\u0026#34;私钥 e = {e}\u0026#34;) # 4. 解密 X = C^e mod n X = pow(C, e, n) print(f\u0026#34;原始明文 X = {X}\u0026#34;) ","date":"2026-01-22T00:00:00Z","image":"https://dongyuzzz5.github.io/p/crypto2/111_hu_16ac7e7036794cdc.png","permalink":"https://dongyuzzz5.github.io/p/crypto2/","title":"Crypto代码积累(二) --- RSA"},{"content":"一. 倒转 “C4” 1. 题目 (1)题干：在神秘的密码世界里，你手上握着两段神秘的光流——它们都是用同一把“魔法钥匙”锁住的。传说中，真正的宝藏在一段被倒转过的秘密信息里，它的模样总是 flag{…}。更神奇的是，你知道其中一段光流其实是用这把钥匙加密了 36 个纯净的小字母 a。 你的任务是：揭开钥匙的秘密，用它去解开另一段光流，从而找回倒转前的真正宝藏。\n(2)数据：\nc0 = bytes.fromhex(\u0026lsquo;fb2941d5308df01996edbe3a841f3c56d845de7de61c20f2da56863563113e58353e\u0026rsquo;)\nc1 = bytes.fromhex(\u0026rsquo;e72f41d837b3e815a8ffac3e90190243d74bdb43e8112df6d368d317500b38583839f 015\u0026rsquo;)\n2. 须知条件 (1) 两段密文 c0、c1 均使用同一字节密钥流做逐字节异或加密\n(2) 其中一段密文对应的明文是 36 个字母 \u0026lsquo;a\u0026rsquo;（即 b\u0026rsquo;a\u0026rsquo; * 36）\n(3) 真正的 flag 藏在另一段密文解密后的结果里，且末尾带一个额外字节需要丢弃\n3. 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 运行前必须准备好的两段十六进制密文（示例值，请替换成真实题目给出的 hex） c0 = bytes.fromhex(\u0026#39;fb2941d5308df01996edbe3a841f3c56d845de7de61c20f2da56863563113e58353e\u0026#39;) c1 = bytes.fromhex(\u0026#39;e72f41d837b3e815a8ffac3e90190243d74bdb43e8112df6d368d317500b38583839f015\u0026#39;) # -------------------------------------------------- print(\u0026#39;c0 长度:\u0026#39;, len(c0)) print(\u0026#39;c1 长度:\u0026#39;, len(c1)) # 根据长度判断哪一段是“36 个 a”加密的结果 if len(c0) == 35: # 说明 c0 对应的是 35 字节明文（题目原文笔误，应为 36） # 这里按题目原始逻辑保留 35，实际比赛时若明文是 36 个 a 则需改成 36 plain_text = b\u0026#39;a\u0026#39; * 35 key_stream = bytes(c0[i] ^ plain_text[i] for i in range(35)) decrypted = bytes(c1[i] ^ key_stream[i] for i in range(35)) flag = decrypted[::-1] print(\u0026#39;Flag:\u0026#39;, flag)# 去掉最后一个多余字节 else: # 否则认为 c1 是 36 个 a 加密的 plain_text = b\u0026#39;a\u0026#39; * 36 key_stream = bytes(c1[i] ^ plain_text[i] for i in range(36)) decrypted = bytes(c0[i] ^ key_stream[i] for i in range(len(c0))) flag = decrypted[::-1] print(\u0026#39;Flag:\u0026#39;, flag) 二. DES-ECB (无iv) 1. 题目 (1)题干：\n(2)数据：\nc = 984134d61dcca6adfd60b24706d5521e02d9d6ee3f82901d\n2. 须知条件 (1) 密文采用 DES-ECB 加密，密钥 8 字节\n(2) 密钥由 2 字节重复 4 次构成\n3. 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from Crypto.Cipher import DES from Crypto.Util.Padding import unpad ciphertext_hex = \u0026#34;984134d61dcca6adfd60b24706d5521e02d9d6ee3f82901d\u0026#34; ciphertext = bytes.fromhex(ciphertext_hex) for key16 in range(0x10000): # 2 bytes: 0x0000 to 0xFFFF key2 = key16.to_bytes(2, \u0026#39;big\u0026#39;) key8 = key2 * 4 # repeat 2 bytes 4 times to get 8 bytes try: cipher = DES.new(key8, DES.MODE_ECB) decrypted = cipher.decrypt(ciphertext) # 去除 PKCS7 填充 plaintext = unpad(decrypted, 8) # 检查是否可打印（flag 一般是可读的） if plaintext.startswith(b\u0026#39;flag\u0026#39;) or plaintext.startswith(b\u0026#39;FLAG\u0026#39;) or b\u0026#39;{\u0026#39; in plaintext: print(f\u0026#34;Key: {key2.hex()} -\u0026gt; {plaintext}\u0026#34;) except (ValueError, Exception): pass 三. 32 位分组的异或 CBC 流加密 1. 题目 (1)题干：\n(2)加密规则与数据： 2. 须知条件 (1) c_ints = [930208137, 2120640298, 544662404, 2004510472, 122086310, 1381519623, 489130696]\n(2) iv = b\u0026rsquo;cbc!\u0026rsquo;\n3. 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #分块长度为4字节 #加密规则：1.c0 = (IV ^ P0) ^ K 2.ci = (c[i-1] ^ Pi) ^ K (i \u0026gt;= 1) c_ints = [930208137, 2120640298, 544662404, 2004510472, 122086310, 1381519623, 489130696] IV = int.from_bytes(b\u0026#39;cbc!\u0026#39;, \u0026#39;big\u0026#39;) # 0x63626321 # 先用 flag 头求出 K P0_guess = int.from_bytes(b\u0026#39;flag\u0026#39;, \u0026#39;big\u0026#39;) K = IV ^ P0_guess ^ c_ints[0] print(\u0026#34;K =\u0026#34;, hex(K)) # 解密 prev = c_ints[0] P0 = IV ^ prev ^ K print(P0.to_bytes(4, \u0026#39;big\u0026#39;).decode(\u0026#39;latin-1\u0026#39;), end=\u0026#34;\u0026#34;) for i in range(1, len(c_ints)): pi = prev ^ c_ints[i] ^ K print(pi.to_bytes(4, \u0026#39;big\u0026#39;).decode(\u0026#39;latin-1\u0026#39;), end=\u0026#34;\u0026#34;) prev = c_ints[i] print() 四. 提供enc和pem文件类的RSA题目 打开题目，这是一道提供enc和pem文件类的RSA题目\n在kali中执行下面该命令，拿到E和N\n1 openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem 将N值从16进制转为十进制，\nN= C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD\n将得到的N值分解出p,q\n进制转换网站：https://www.jyshare.com/unit-conversion/7999/\n分解N网站：http://www.factordb.com/index.php\n接着在 Kai 的终端中，进入存放私钥生成脚本的目录，执行以下命令创建脚本文件 1 touch gen private.py 用文本编辑器(如 nano)打开脚本并写入内容 1 nano gen private.py 写入内容如下（p,q,e都为前面求出的值）：\n1 2 3 4 5 6 7 8 9 10 11 from Crypto.PublicKey import RSA p = 275127860351348928173285174381581152299 q = 319576316814478949870590164193048041239 e = 65537 n = p * q phi = (p - 1) * (q - 1) d = pow(e, -1, phi) key = RSA.construct((n, e, d, p, q)) with open(\u0026#34;private.pem\u0026#34;, \u0026#34;wb\u0026#34;) as f: f.write(key.exportKey()) print(\u0026#34;私钥文件private.pem已生成\u0026#34;) 接着用命令运行脚本 1 python3 gen private.py 接着在终端执行该命令生成txt文件，拿到flag 1 openssl pkeyutl -decrypt -in flag.enc -inkey private.pem -out flag.txt 若此命令无法执行，可能需用到虚拟环境，按顺序执行以下命令即可，如下：\n配置好虚拟环境后再执行下面该命令\n1 openssl pkeyutl -decrypt -in flag.enc -inkey private.pem -out flag.txt ","date":"2026-01-22T00:00:00Z","image":"https://dongyuzzz5.github.io/p/crypto1/111_hu_ebd8c6454af66c61.png","permalink":"https://dongyuzzz5.github.io/p/crypto1/","title":"Crypto其他题目"},{"content":"一. AES-128-CBC 1. 须知条件 (1) ciphertext = ebd91f0fc53e3d9e2fa5e5ecec1d2ea878a068f6db0c871ac6d14b83bfdb764f\n(2) iv = 25ef3189e66193cf3e70f74d3f7b18f0\n(3) key = 00112233445566778899aabbccddeeff\n2. 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/usr/bin/env python3 from Crypto.Cipher import AES from Crypto.Util.Padding import unpad KEY_HEX = \u0026#34;00112233445566778899aabbccddeeff\u0026#34; IV_HEX = \u0026#34;25ef3189e66193cf3e70f74d3f7b18f0\u0026#34; CIPHER_HEX = \u0026#34;ebd91f0fc53e3d9e2fa5e5ecec1d2ea878a068f6db0c871ac6d14b83bfdb764f\u0026#34; key = bytes.fromhex(KEY_HEX) iv = bytes.fromhex(IV_HEX) ct = bytes.fromhex(CIPHER_HEX) cipher = AES.new(key, AES.MODE_CBC, iv) pt_padded = cipher.decrypt(ct) pt = unpad(pt_padded, 16) print(pt.decode()) 二. AES-256-CBC 1. 须知条件 (1) ciphertext = 5435496e404858cfa2ba08e8ac4f421fd43c289ee54f699da3e403ceff19d8d0\n(2) iv 为 key 的前 16 字节\n(3) 这是个pin (对PIN码哈希生成32字节的AES-256密钥)\n2. 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import hashlib from Crypto.Cipher import AES from Crypto.Util.Padding import unpad # 密文（16进制格式） ciphertext_hex = \u0026#34;5435496e404858cfa2ba08e8ac4f421fd43c289ee54f699da3e403ceff19d8d0\u0026#34; ciphertext = bytes.fromhex(ciphertext_hex) # 尝试用 PIN 解密 def decrypt_with_pin(pin): # 1. 用 SHA256 对PIN码哈希生成32字节的AES-256密钥 key = hashlib.sha256(pin.encode()).digest() # sha256固定输出32字节，刚好满足AES-256的密钥长度要求 # 2. IV(初始化向量) 是 Key 的前 16 字节 iv = key[:16] # 3. 解密（AES-256-CBC 模式） cipher = AES.new(key, AES.MODE_CBC, iv) try: # 解密后去除PKCS7填充，AES分组长度固定16字节 plaintext = unpad(cipher.decrypt(ciphertext), AES.block_size) return plaintext.decode(\u0026#39;utf-8\u0026#39;) # 明文为UTF-8编码的文本 except (ValueError, UnicodeDecodeError): # 解密失败的常见原因：PIN错误、填充错误、明文编码不符 return None # 暴力枚举 4位纯数字PIN码 (范围：0000 ~ 9999) found = False for pin in range(0, 1000000): pin_str = f\u0026#34;{pin:04d}\u0026#34; # 格式化补零为4位，如 12 → 0012，999 → 0999 plaintext = decrypt_with_pin(pin_str) if plaintext: print(f\u0026#34;✅ 成功解密！PIN: {pin_str}, 明文: {plaintext}\u0026#34;) found = True break if not found: print(\u0026#34;❌ 未找到匹配的 PIN 爆破范围内\u0026#34;) 三. AES-128-CBC (密文base64编码) 1. 须知条件 (1) ciphertext = l60f2FRTj/w6MlIhLWv/rlzEkIhsopz0VcY4W01XvVU= (base64编码)\n(2) iv = 1229002635654321\n(3) key = hellomyaeskeyyyy\n2. 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import base64 from Crypto.Cipher import AES # 给定的参数 IV = \u0026#34;1229002635654321\u0026#34; # 初始化向量 KEY = \u0026#34;hellomyaeskeyyyy\u0026#34; # AES密钥 ENCRYPTED_FLAG = \u0026#34;l60f2FRTj/w6MlIhLWv/rlzEkIhsopz0VcY4W01XvVU=\u0026#34; # Base64编码的密文 def decrypt_aes_cbc(key, iv, ciphertext_b64): # Base64解码 ciphertext = base64.b64decode(ciphertext_b64) # 初始化AES-CBC解密器 cipher = AES.new(key.encode(\u0026#39;utf-8\u0026#39;), AES.MODE_CBC, iv.encode(\u0026#39;utf-8\u0026#39;)) # 解密 plaintext = cipher.decrypt(ciphertext) # 去除填充（原代码使用空格填充） plaintext = plaintext.decode(\u0026#39;utf-8\u0026#39;).rstrip(\u0026#39; \u0026#39;) return plaintext # 解密并输出flag flag = decrypt_aes_cbc(KEY, IV, ENCRYPTED_FLAG) print(\u0026#34;Flag:\u0026#34;, flag) 四. AES-128-CTR 1. 须知条件 (1) ciphertext = ad49684af40fb9d2372d32e0df4c8fc1afc843af873f36e79f98c57a81\n(2) nonce(计算器前缀) = 6874f1abe89d9025\n(3) key = SHA256(PIN || Salt) (取前16字节)\n2. 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from Crypto.Cipher import AES from Crypto.Util import Counter import hashlib def derive_16byte_key(pin: str, salt: str) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;生成16字节密钥（取SHA256的前16字节）\u0026#34;\u0026#34;\u0026#34; full_key = hashlib.sha256((pin + salt).encode()).digest() return full_key[:16] # 取前16字节作为AES-128密钥 def decrypt_ctr(key: bytes, nonce: bytes, ciphertext: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;AES-CTR解密（使用16字节密钥）\u0026#34;\u0026#34;\u0026#34; ctr = Counter.new(64, prefix=nonce, initial_value=0) cipher = AES.new(key, AES.MODE_CTR, counter=ctr) return cipher.decrypt(ciphertext) def brute_force_decrypt(ciphertext_hex: str, nonce_hex: str): \u0026#34;\u0026#34;\u0026#34;暴力破解PIN和salt组合\u0026#34;\u0026#34;\u0026#34; ciphertext = bytes.fromhex(ciphertext_hex) nonce = bytes.fromhex(nonce_hex) # 完整5位PIN范围 00000-99999，补零格式化 for pin in range(0, 100000): pin_str = f\u0026#34;{pin:05d}\u0026#34; for salt in range(0, 100): salt_str = f\u0026#34;{salt:02d}\u0026#34; # 进度提示 if pin % 1000 == 0 and salt == 0: print(f\u0026#34;尝试中: PIN={pin_str}, Salt={salt_str}\u0026#34;) # 生成密钥并解密，无多余异常捕获 key = derive_16byte_key(pin_str, salt_str) plaintext = decrypt_ctr(key, nonce, ciphertext) if b\u0026#34;flag{\u0026#34; in plaintext: print(\u0026#34;\\n✅ 解密成功！\u0026#34;) print(f\u0026#34;PIN: {pin_str}, Salt: {salt_str}\u0026#34;) print(f\u0026#34;明文: {plaintext.decode(\u0026#39;utf-8\u0026#39;)}\u0026#34;) return print(\u0026#34;❌ 未找到正确组合\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: ciphertext_hex = \u0026#34;ad49684af40fb9d2372d32e0df4c8fc1afc843af873f36e79f98c57a81\u0026#34; nonce_hex = \u0026#34;6874f1abe89d9025\u0026#34; print(\u0026#34;开始暴力破解...\u0026#34;) brute_force_decrypt(ciphertext_hex, nonce_hex) ","date":"2026-01-21T00:00:00Z","image":"https://dongyuzzz5.github.io/p/crypto/111_hu_cf12af5b25e60a51.png","permalink":"https://dongyuzzz5.github.io/p/crypto/","title":"Crypto代码积累(一) --- AES"},{"content":"简介 《坎特伯雷公主与骑士唤醒冠军之剑的奇幻冒险》是一款由Kong Studios开发，哔哩哔哩代理的手机游戏 ，于2021年4月27日公测。 游戏中玩家将扮演一名骑士团新兵，穿梭于不同世界保护小公主不受威胁，拯救被黑暗力量侵蚀的王国。\n配置要求（安卓） 操作系统：Android5.0及以上\n运行内存：2GB及以上\n存储空间：6GB及以上\n图片 ","date":"2026-01-06T00:00:00Z","image":"https://dongyuzzz5.github.io/p/test-chinese/%E5%B0%81%E9%9D%A21_hu_b4b6b95b74e6f795.png","permalink":"https://dongyuzzz5.github.io/p/test-chinese/","title":"坎公骑冠剑"}]